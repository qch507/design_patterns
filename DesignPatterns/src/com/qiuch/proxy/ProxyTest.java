package com.qiuch.proxy;

/**
 * 代理模式的应用场景：
 * 
 * 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
 * 
 * 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
 * 
 * 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
 * 
 * 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
 * 
 * 
 * ------------------------------------------------------------------------------------------------
 * 
 * (1)远程代理(Remote Proxy) -可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，
 * 远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
 * 
 * (2)虚拟代理(Virtual Proxy) – 允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。
 * 
 * (3)写入时复制代理(Copy-On-Write Proxy) – 用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。
 * 
 * (4)保护代理(Protection (Access)Proxy) – 为不同的客户提供不同级别的目标对象访问权限
 * 
 * (5)缓存代理(Cache Proxy) – 为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。
 * 
 * (6)防火墙代理(Firewall Proxy) – 控制网络资源的访问，保护主题免于恶意客户的侵害。
 * 
 * (7)同步代理(SynchronizationProxy) – 在多线程的情况下为主题提供安全的访问。
 * 
 * (8)智能引用代理(Smart ReferenceProxy) - 当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。
 * 
 * (9)复杂隐藏代理(Complexity HidingProxy) –用来隐藏一个类的复杂集合的复杂度，并进行访问控制。
 * 有时候也称为外观代理(Façade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，
 * 而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。
 * 
 * @author qiuch
 *
 */
public class ProxyTest {
	public static void main(String[] args) {
		Person p = new Person();
		p.setName("tom");
		p.setMoney(1500);
		RentHouse rentHouse = new RentProxy(p);
		rentHouse.rent();

		p.setMoney(500);
		rentHouse.rent();
	}
}
